"""Markdown output generation for plans."""

from __future__ import annotations

from datetime import datetime
from pathlib import Path
from typing import TYPE_CHECKING

from jinja2 import Environment, FileSystemLoader, BaseLoader

if TYPE_CHECKING:
    from planify.orchestrator import Session


# Default template when no file template is available
DEFAULT_TEMPLATE = """# Plan: {{ title }}

**Agent**: Planify ({{ agents }})
**Status**: {{ status }}
**Created**: {{ created }}
**Rounds**: {{ rounds }}
**Total Cost**: ${{ "%.4f"|format(cost) }}

---

{{ final_plan }}

{% if doc_impacts %}
---

## Doc Updates Required

{{ doc_impacts }}
{% endif %}

---

{% if include_transcript %}
## Planning Transcript

{% for turn in conversation %}
### {{ turn.phase|title }} ({{ turn.model }})
_Cost: ${{ "%.4f"|format(turn.cost_usd) }} | Tokens: {{ turn.input_tokens }} in / {{ turn.output_tokens }} out_

{{ turn.content }}

{% if turn.human_feedback %}
**Human Feedback**: {{ turn.human_feedback }}
{% endif %}

---

{% endfor %}
{% endif %}

_Generated by [Planify](https://github.com/your-repo/planify) | Total cost: ${{ "%.4f"|format(cost) }}_
"""


class MarkdownGenerator:
    """Generate markdown output from planning sessions."""

    def __init__(self, template_dir: Path | None = None):
        """Initialize the generator.

        Args:
            template_dir: Directory containing custom templates (optional)
        """
        self.template_dir = template_dir

        if template_dir and template_dir.exists():
            self.env = Environment(
                loader=FileSystemLoader(str(template_dir)),
                autoescape=False,
            )
        else:
            self.env = Environment(
                loader=BaseLoader(),
                autoescape=False,
            )

    def generate(
        self,
        session: "Session",
        include_transcript: bool = False,
        doc_impacts_markdown: str | None = None,
    ) -> str:
        """Generate markdown from a session.

        Args:
            session: The planning session
            include_transcript: Whether to include the full conversation
            doc_impacts_markdown: Pre-rendered doc impacts markdown (optional)

        Returns:
            Markdown string
        """
        # Extract the final plan (from the last integrator turn)
        final_plan = self._extract_final_plan(session)

        # Build title from task
        title = self._extract_title(session.task, final_plan)

        # Get list of agents used
        agents = self._get_agents_used(session)

        # Prepare template context
        context = {
            "title": title,
            "task": session.task,
            "status": session.status.value.replace("_", " ").title(),
            "created": self._format_date(session.created_at),
            "rounds": session.round,
            "cost": session.total_cost_usd,
            "agents": agents,
            "final_plan": final_plan,
            "conversation": [t.to_dict() for t in session.conversation],
            "include_transcript": include_transcript,
            "files_loaded": session.files_loaded,
            "doc_impacts": doc_impacts_markdown,
        }

        # Try to load custom template, fall back to default
        try:
            if self.template_dir and (self.template_dir / "plan.md.jinja").exists():
                template = self.env.get_template("plan.md.jinja")
            else:
                template = self.env.from_string(DEFAULT_TEMPLATE)
        except Exception:
            template = self.env.from_string(DEFAULT_TEMPLATE)

        return template.render(**context)

    def save(
        self,
        session: "Session",
        output_path: Path,
        include_transcript: bool = False,
        doc_impacts_markdown: str | None = None,
    ) -> Path:
        """Generate and save markdown to a file.

        Args:
            session: The planning session
            output_path: Path to save to (can use {slug} placeholder)
            include_transcript: Whether to include the full conversation
            doc_impacts_markdown: Pre-rendered doc impacts markdown (optional)

        Returns:
            Path to the saved file
        """
        # Generate markdown
        markdown = self.generate(session, include_transcript, doc_impacts_markdown)

        # Resolve path with slug placeholder
        if "{slug}" in str(output_path):
            slug = session.id.split("-", 3)[-1] if "-" in session.id else session.id
            output_path = Path(str(output_path).replace("{slug}", slug))

        # Create parent directories
        output_path.parent.mkdir(parents=True, exist_ok=True)

        # Write file
        output_path.write_text(markdown, encoding="utf-8")

        return output_path

    def _extract_final_plan(self, session: "Session") -> str:
        """Extract the final plan from the session.

        Args:
            session: The planning session

        Returns:
            Final plan content
        """
        # Look for the last integrator turn
        for turn in reversed(session.conversation):
            if turn.phase == "integrator":
                return turn.content

        # Fall back to last architect turn if no integrator
        for turn in reversed(session.conversation):
            if turn.phase == "architect":
                return turn.content

        # Fall back to last turn
        if session.conversation:
            return session.conversation[-1].content

        return "No plan generated."

    def _extract_title(self, task: str, plan: str) -> str:
        """Extract a title from the task or plan.

        Args:
            task: The original task
            plan: The generated plan

        Returns:
            Title string
        """
        # Try to extract title from plan (look for "# Plan: X" pattern)
        import re

        match = re.search(r"^#\s*Plan:\s*(.+)$", plan, re.MULTILINE)
        if match:
            return match.group(1).strip()

        # Fall back to first line of task (truncated)
        first_line = task.split("\n")[0].strip()
        if len(first_line) > 50:
            first_line = first_line[:47] + "..."

        return first_line

    def _get_agents_used(self, session: "Session") -> str:
        """Get a string listing agents used.

        Args:
            session: The planning session

        Returns:
            Agent list string
        """
        phases = set(t.phase for t in session.conversation)

        agents = []
        if "architect" in phases or "rebuttal" in phases:
            agents.append("Architect")
        if "critic" in phases:
            agents.append("Critic")
        if "integrator" in phases:
            agents.append("Integrator")

        return " + ".join(agents) if agents else "Unknown"

    def _format_date(self, iso_date: str) -> str:
        """Format an ISO date string.

        Args:
            iso_date: ISO format date string

        Returns:
            Formatted date string
        """
        try:
            dt = datetime.fromisoformat(iso_date.replace("Z", "+00:00"))
            return dt.strftime("%Y-%m-%d %H:%M UTC")
        except (ValueError, AttributeError):
            return iso_date
